# LMSR Notes

## [Survey of Automated Market Making Algorithms](https://medium.com/terra-money/survey-of-automated-market-making-algorithms-951f91ce727a)

- LMSR，即`Logarithmic Market Scoring Rule` **对数市场评分规则**

- 做市商的职责在于决定潜在交易者的定价，我们可以确定的是价格应该和每个不同的结果的概率相关

- 为了获得市场中对于买卖双方的信息，我们构造了一个成本函数：

  ![image-20210606224016943](https://raw.githubusercontent.com/Whisker17/ImageStoreService/main/image-20210606224016943.png)

  这个看起来有些复杂的函数将流通在外的股票映射到做市商必须收到的美元金额才能接受这些赌注。

- b是另一个输入。它被称为流动性参数，它控制着边际价格随交易的变化。当b很小时，价格变化很快，当b很大时，价格变化缓慢。

- 对于交易员来说，他在决定是否想从做市商手中购买时，必须考虑某个结果获胜的可能性。例如，如果交易者认为爱国者队有60%的机会获胜，那么他的预期利润包括60%的机会他赢得0.49美元(他得到的1.00美元减去他支付的0.51美元)和40%的机会他损失0.51美元。净预期是0.6 *(1-0.51)+ 0.4 *(-0.51)，即利润0.09美元。正如这个例子所示，在这种类型的市场中，只要价格暗示一个低于他/的概率，交易者就会被激励去购买股票

## [How does the Logarithmic Market Scoring Rule (LMSR) work?](https://www.cultivatelabs.com/prediction-markets-guide/how-does-logarithmic-market-scoring-rule-lmsr-work)

- **价格函数**

![image-20210522203737262](https://raw.githubusercontent.com/Whisker17/ImageStoreService/main/image-20210522203737262.png)

- **花费函数**

  ![image-20210606224016943](https://raw.githubusercontent.com/Whisker17/ImageStoreService/main/image-20210606224016943.png)

- b 值的确定

  b 值的确定很大程度上取决于市场本身，对于那些比较小的市场而言，它们的交易次数会比较少，那么我们就会选择一个比较小的 b，这样可以对于现实事件进行比较快的响应。

## [How does Hanson's Market Maker (LMSR) work?](https://quant.stackexchange.com/questions/7826/how-does-hansons-market-maker-lmsr-work)

LMSR 产生了一个跷跷板。这可以通过收取略大的价差来降低，这对 b 有贡献。通过这种方式，b 有效地成为做市基金，**波动性随着交易量的增加而降低**。这使得 LMSR 做市商的流动性变得敏感。

随着交易传授价格知识并补贴流动性，价差随着时间的推移而减小，这使得市场更加有效。

------

## [A Practical Liquidity-Sensitive Automated Market Maker](https://www.cs.cmu.edu/~./sandholm/liquidity-sensitive%20automated%20market%20maker.teac.pdf)

自动做市商是一种算法代理，能够参与数字市场并获取信息。它们已经被广泛、成功地应用于人造货币环境中，比如网络预测市场。文献中的自动做市商存在两个问题，这两个问题导致了它们的不切实际，并削弱了它们在人为货币设置之外的使用：

1. 他们不能适应流动性，因此导致价格在交易量大和交易量小的市场上变动相同。

2. 在某些情况下，它们会出现赤字。

在本文中，我们构建了一个既对流动性敏感又能盈利的做市商。我们的做市商对任何初始流动性水平的损失都是有限的，当初始流动性水平趋于零时，最坏情况下的损失也趋于零。对于任何初始流动性水平，我们可以在市场状态空间中建立一个边界，这样，如果市场在该边界内终止，做市商无论实现的结果如何，都将记入利润。

自动做市商在流动性比较低的市场中充当一个对手盘，同时在复杂环境下，AMM 也是必要的，比如组合预测市场中，有64个球队，那么结果就有 2^63 个。

**LMSR 中的流动性是在做市商知道交易员将押注什么之前预先设定的一个参数。** 

流动性过少会导致每次交易后价格大幅波动；过多会使价格几乎没有变动，即使是在大赌注之后。雪上加霜的是，LMSR 中一个固定押注的价格变动量是恒定的。第 10 亿美元和第 1 亿美元对价格的影响是一样的。这不是真正的货币市场的表现方式；像热门股票这样交易频繁的资产，买卖价差正在消失，进入或退出大仓位的能力不会对当前价格产生重大影响，而像精品债券这样交易清淡的资产则有巨大的交易成本。

流动性对交易员有利，但代价是增加做市商的最坏损失。一般来说，LMSR 运营商的损失与其提供的流动性成比例。这种成本被合理化为对交易者信息的支付。

在本文中，我们将介绍 LMSR 的一种变体，它在两方面更适合于实际使用：

1. 首先，我们的做市商会根据看到的交易活动的多少，自动调整价格变动的容易程度：随着更多美元流入，价格弹性会降低。市场经营者不需要试图预测交易员的兴趣水平来手动设定流动性。
2. 其次，我们的做市商可以确保在最坏情况下的任意小损失，并在很大范围的最终状态下获得正利润。

**在 LMSR 中，不相交资产的价格总和总是恰好为 $1**。在我们的做市商中，价格之和可以大于1美元。但是，我们证明了对于所有对流动性敏感且与路径无关的做市商，放弃总和属性是一项理论要求

## [IMPLEMENTING HANSON'S MARKET MAKER](http://blog.oddhead.com/2006/10/30/implementing-hansons-market-maker/)

Hanson 更倾向于用 “改变价格” 来阐述交易者的行为，而不是 “买卖股票” 。

假设 q1 和 q2 是二元预测市场中的两种结果分别的流通量，做市商维护了一个成本函数，记录了交易者到目前为止花费的成本：

C = b * ln(eq1/b+eq2/b)

参数 b 控制做市商可能损失的最大金额。b 越大就意味着：

1. 做市商可损失的钱越多
2. 市场具有更大的流动性或者深度，这意味着交易者可以在当前价格或接近当前价格的情况下购买更多股票，而不会引起巨大的价格波动。

同时，做市商如果想要报价当前的价格，只需要遵守以下的函数：

price1 = eq1/b/(eq1/b+eq2/b)

需要注意的是，当前价格仅适用于购买**少量**（实际上是无限的）股票。交易者开始购买后，价格立即开始上涨。

**价格函数的积分就是成本函数。**

## [Automated Market Makers for Prediction Markets](https://docs.gnosis.io/conditionaltokens/docs/introduction3/)

预测市场对于流动性函数的要求非常高。

LMSR 在应用于组合预测市场时会分解为自相似的组件。

LMSR 和 CPMM 两种 AMM 的异同：

1. 使用 LMSR 进行买卖的封闭式表达式允许计算同时完成的一批买卖的净成本。CPMM 不允许在预测市场用例中使用这种表达方式，因此，买卖合同上的交易仅限于一次使用一个结果代币。

2. CPMM 的表达式更加简单，可以很轻松地动态众筹，但 LMSR 不能。

## [LSD-LMSR](https://github.com/zeitgeistpm/LSD-LMSR)

- **项目结构解析**

  - **lsdLMSRCoreFunctions.py**

    包含进行模型计算的主要功能

  - **LSD-LMSR.py**

    包含模拟（这是您需要执行的文件）

  - 在 `LSD-LMSR.py` 文件里面你可以进行修改的参数：

    - **traderMaxFee**：交易者为进行交易愿意支付的最高交易费
    - **b**：流动性池需要为流动性提供者保证的初始交易费比例
    - **q_1 和 q_2** ：这定义了为池引入界限的标准（此时交易费设置的是 50%。如果你想修改它，在第 103 行中将 0.5 更改为 0 和 1 之间的任何值）
    - **73 行的 500**：表示市场信号（买入或卖出更多资产的权重）保持不变的时间量

  - 在 `lsdLMSRCoreFunctions.py` 文件里面你可以进行修改的参数：
    - z 函数：现在我们使用 sigmoid 函数（一种在生物学中常见的S型函数，也称为S型生长曲线。在信息科学中，由于其单增以及反函数单增等性质，*Sigmoid*函数常被用作神经网络的激活函数，将变量映射到0,1之间。），但您可以使用任何满足以下要求的函数：
      1.  采用 r 参数等于短期交易量与长期交易量之间的比率
      2.  z 和 r 的一阶偏导数是非负数
  
  - **模拟机制**
  
    在观察和修改（或不修改）前面提到的一般特征后，模拟将以如下形式工作：
  
    1. 首先，创建一个与初始阶段相对应的字典。
    2. 然后开始一个循环，它会开始随机决定交易者将交易哪些资产。
    3. 在决定这个迭代是否代表一个买入或卖出操作之后（由每 500 个周期变化的每种资产的可能性变化的随机选择决定），这个决定将受到一个被解释为市场信号解释的权重的影响，该权重也会每 500 次操作（循环迭代）改变一次。
  
    在每次迭代中，该资产的随机数量将被添加到资金池中，并且该数量的资产将从为该资产分配的最大数量中提取。
  
    如果资金池存在流动性问题，交易费将大幅增加以阻止交易，直到这种危险降低。
  
    总迭代次数相当于 4 秒（区块时间）内进行的交易总量。模拟完成后，会生成一个 csv 文件，其中包含该时间段内进行的所有交易信息，以及一些散点图，以探索其他感兴趣的关系。

- **内部讨论**

  - Q：当市场开始时，我们没有该资产过去的 EMA 信息。 如果我们使用短周期，我们将在连续的 EMA_t / EMA_t+k 比率中出现高离散度。 这将在第一次有效地导致交易费用的高度波动，直到 EMA 稳定下来。 假设我写的是正确的：我们是否想在第一期使用 LS LSMR，然后在有足够的数据后切换到 LSD LSMR，我们是否一直使用 LSD LSMR 并使用静态费用 f 直到收集到足够的数据 ，还是完全不同的东西？

    A：是的，对于这种情况，我们会让总费用等于初始费用（固定费用），因为 r 参数将为 1，并且在等式中我们有一个 (rn) 项，默认情况下 n 是 1

  - Q：费用调整的动态和类似性质可能会给基于去中心化区块链的市场带来一些困难：状态大约每 6 秒更新一次。每个用户都会看到系统的旧状态并根据“旧”状态进行交易。例如：对于资产 x,y,z，我们有金额 [ax, ay, az]、价格 [pxy, pxz, pyz] 和费用 [fxy, fxz, fyz]。每个交易者同时进行这些交易，他们发送一个交易，涵盖他们的操作，该交易至少在下一次状态更新中与其他交易以未指定的顺序包含在内，在更高的负载甚至更高的状态更新。因此，可能是“同时”（意味着拥有相同的旧信息），成千上万的交易者用 x 交易 y 以获得价格 pxy 和 fxy，然后在某一时刻将这些交易收集到一个区块中并进行评估。如果在每次交易后动态计算费用更新，那么最后处理订单的不幸交易者可能不得不支付可怕的费用。我的假设是否正确，在几笔交易中，如果它们导致“冲击”情况，费用可以进行极大的调整？这是否会被更高的 EMA 期限所缓解？如果是，这将如何影响 DMM 和 LP 的收入？如果情况属实，我们可以为交易者实施可接受的费用范围，当费用上涨过多时，订单将被取消而不是执行。但由于 PoS 和区块创作的性质，这可能导致交易者向区块作者支付订单的良好执行头寸。

    A：是的，所以这是一个有趣的观点。 说到对资产的需求激增，我认为我们有两种类型：冲击和结构变化。 冲击是偶尔发生的大额交易，出于 X 原因，它们可以被视为一个孤立的案例（想象一下埃隆马斯克关于抽 DOGE 的推文）。 另一方面，结构变化是突然发生的变化，但这种趋势会随着时间的推移而保持（想象一下，我们有一个与总统选举结果相关的 2 个可能结果的市场，一个候选人的视频突然间客观伤害 它的图像进来了）。 EMA 的好处是，对于第一种情况，未来的交易者不会在更长的时间内被收取太多费用，因为这种“冲击”与之前的观察结果相吻合。 另一方面，结构的变化将意味着臭名昭著的交易量变化，这将转化为臭名昭著的费用增加一开始，当斜率降低时，费用也会这样做

- 花费函数：

  ![image-20210608101605759](https://raw.githubusercontent.com/Whisker17/ImageStoreService/main/image-20210608101605759.png)

id: 5c515056ce4145fda644ede3e5fb1e8e
parent_id: 69c408ac4e0f4e84b2948bf79c77e89b
created_time: 2021-06-06T10:43:57.694Z
updated_time: 2021-06-08T02:47:36.574Z
is_conflict: 0
latitude: 0.00000000
longitude: 0.00000000
altitude: 0.0000
author: 
source_url: 
is_todo: 0
todo_due: 0
todo_completed: 0
source: joplin-desktop
source_application: net.cozic.joplin-desktop
application_data: 
order: 0
user_created_time: 2021-06-06T10:43:57.694Z
user_updated_time: 2021-06-08T02:47:36.574Z
encryption_cipher_text: 
encryption_applied: 0
markup_language: 1
is_shared: 0
type_: 1